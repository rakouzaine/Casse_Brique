"""
Éditeur de Spyder

Ceci est un script temporaire.
"""

# -*- coding: utf-8 -*-
"""
Jeu du casse-briques — version corrigée pour exécution
(Correspond aux classes de ton fichier ; corrections minimes
pour que le programme se lance.)
"""

import tkinter as tk
import math
import random
from tkinter import Canvas, Frame, Label, LEFT, RIGHT

# -------------------------- CLASSES -------------------------------------

class Creation_Brique:
    def __init__(self, canvas: Canvas):
        """Initialise le gestionnaire de briques."""
        self.canvas = canvas
        self.bricks = []  # Liste qui stocke les briques (id + coordonnées)

    def create_brique(self):
        """Crée et affiche les briques sur le canvas."""
        n = 10       # nombre de briques par ligne
        rows = 5     # nombre de lignes
        x0 = 40      # x de départ
        y0 = 50      # y de départ
        w = 60       # largeur d'une brique
        h = 20       # hauteur d'une brique
        gap = 5      # espace entre deux briques

        color = "blue"  # couleur unique pour toutes les briques

        for j in range(rows):
            for i in range(n):
                x1 = x0 + i * (w + gap)
                y1 = y0 + j * (h + gap)
                x2 = x1 + w
                y2 = y1 + h

                brick_id = self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, outline="")
                self.bricks.append({
                    "id": brick_id,
                    "x1": x1,
                    "y1": y1,
                    "x2": x2,
                    "y2": y2
                })

    def brick_hit_at(self, x, y):
        """Supprime une brique si le point (x, y) entre en collision avec elle."""
        for brick in list(self.bricks):  # itérer sur une copie car on peut supprimer
            if brick["x1"] <= x <= brick["x2"] and brick["y1"] <= y <= brick["y2"]:
                self.canvas.delete(brick["id"])
                self.bricks.remove(brick)
                return True
        return False



class Score:
    def __init__(self, root):
        # Utilisation de Frame/Label tels qu'ils étaient dans ton fichier
        self.frame = Frame(root)
        self.label_score = Label(self.frame, text="Score : 0")
        self.label_vies = Label(self.frame, text="Vies : 3")
        self.label_vies.pack(side=LEFT, padx=10)
        self.label_score.pack(side=RIGHT, padx=10)
        
    def pack(self):
        self.frame.pack()

    def modifier(self, score=None, vies=None):
        if score is not None:
            self.label_score.config(text=f"Score : {score}")
        if vies is not None:
            self.label_vies.config(text=f"Vies : {vies}")
            
            
class Creation_Balle:
    def __init__(self, canvas, x, y, rayon=8, vitesse=6):
        self.canvas = canvas
        self.x = x
        self.y = y
        self.rayon = rayon
        self.vitesse = vitesse

        # direction initiale vers le haut (valeur vy négative)
        angle = random.uniform(-math.pi/4, math.pi/4)
        self.vx = vitesse * math.sin(angle)
        self.vy = -abs(vitesse * math.cos(angle))

        # Dessiner la balle
        self.id = canvas.create_oval(x-rayon, y-rayon, x+rayon, y+rayon, fill="red")

    def move(self):
        self.x += self.vx
        self.y += self.vy
        self.canvas.coords(self.id, self.x-self.rayon, self.y-self.rayon, self.x+self.rayon, self.y+self.rayon)


class MouvementPlateforme:
    def __init__(self, canvas: tk.Canvas):
        self.canvas = canvas
        self.vx = 0          # vitesse horizontale
        self.speed = 10      # pixels par tick
        
    def plateforme(self):
        self.plat = self.canvas.create_rectangle(240, 372, 360, 388, fill="#333")
        return self.plat

    # méthodes non utilisées directement pour les bindings (contrôle via Deplacement_Clavier_plateforme)
    def _left(self):
        self.vx = -self.speed

    def _right(self):
        self.vx = self.speed

    def _stop(self):
        self.vx = 0


class Deplacement_Clavier_plateforme:
    def __init__(self, root: tk.Tk, mp: MouvementPlateforme, fps: int = 60):
        self.root = root
        self.mp = mp
        self.W = int(self.mp.canvas.cget("width"))

        # Bind clavier (flèches)
        root.bind("<Left>",  self._left)
        root.bind("<Right>", self._right)
        root.bind("<KeyRelease-Left>",  self._stop)
        root.bind("<KeyRelease-Right>", self._stop)

        # Boucle d'update
        self.period_ms = max(1, int(1000 / fps))
        self._tick()

    def _left(self, _evt):
        self.mp.vx = -self.mp.speed

    def _right(self, _evt):
        self.mp.vx = self.mp.speed

    def _stop(self, _evt):
        self.mp.vx = 0

    def _tick(self):
        # Si on a une vitesse horizontale, on essaie de bouger
        if self.mp.vx != 0:
            x1, y1, x2, y2 = self.mp.canvas.coords(self.mp.plat)
            dx = self.mp.vx

            # arrêt aux bords
            if x1 + dx < 0:
                dx = -x1
            elif x2 + dx > self.W:
                dx = self.W - x2

            if dx != 0:
                self.mp.canvas.move(self.mp.plat, dx, 0)  # déplacement uniquement sur X

        self.mp.canvas.after(self.period_ms, self._tick)


# ------------------------- PROGRAMME PRINCIPAL ---------------------------

# Fenêtre et canvas (créés ici — accessible globalement aux callbacks)
root = tk.Tk()
root.title("Jeu du casse-briques")
root.configure(bg="bisque")

canvas_width = 720
canvas_height = 400

canvas = Canvas(root, width=canvas_width, height=canvas_height, bg="black")
canvas.pack(pady=20)


begin_button = tk.Button(root, text="Commencer")
begin_button.pack(side=tk.LEFT, padx=5, pady=5)

quit_button = tk.Button(root, text="Quitter", command=root.destroy)
quit_button.pack(side=tk.LEFT, padx=5, pady=5)


def on_begin():
    """Lance la partie du casse-brique."""
    begin_button.config(state="disabled") #l’utilisateur ne peut plus cliquer dessus une fois la partie commencée.
    #canvas.delete("all")

    # Création des éléments du jeu
    gestion_brique = Creation_Brique(canvas)
    gestion_brique.create_brique()

    plateforme = MouvementPlateforme(canvas)
    plat_id = plateforme.plateforme()

    controle = Deplacement_Clavier_plateforme(root, plateforme)

    score_systeme = Score(root)
    score_systeme.pack()
    score = 0
    vies = 3
    score_systeme.modifier(score=score, vies=vies)

    # Centre de départ de la balle (au-dessus de la plateforme)
    start_x = (240 + 360) / 2
    start_y = 350

    balle = Creation_Balle(canvas, start_x, start_y, rayon=8, vitesse=6)

    # Boucle de jeu
    def game_loop():
        nonlocal score, vies

        balle.move()
        bx, by = balle.x, balle.y
        r = balle.rayon

        # Rebonds sur les murs
        if bx - r <= 0:
            balle.vx = abs(balle.vx)
        if bx + r >= canvas_width:
            balle.vx = -abs(balle.vx)
        if by - r <= 0:
            balle.vy = abs(balle.vy)

        # Rebond sur la plateforme (simple test par centre de la balle)
        px1, py1, px2, py2 = canvas.coords(plat_id)
        # On considère rebond seulement si la balle descend (vy > 0)
        if  (py1 - r <= by <= py2) and (px1 <= bx <= px2):
            balle.vy = -abs(balle.vy)
            # effet d'angle
            centre_plat = (px1 + px2) / 2
            offset = (bx - centre_plat) / ((px2 - px1) / 2)
            balle.vx = balle.vitesse * offset

        # Collision avec une brique (on teste le centre)
        if gestion_brique.brick_hit_at(bx, by):
            balle.vy = -balle.vy
            score += 10
            score_systeme.modifier(score=score)

        # Si la balle tombe
        if by - r > canvas_height:
            vies -= 1
            score_systeme.modifier(vies=vies)
            if vies <= 0:
                canvas.create_text(canvas_width/2, canvas_height/2, text="GAME OVER",
                                   fill="white", font=("Arial", 28, "bold"))
                begin_button.config(state="normal")
                return
            else:
                # remettre la balle au-dessus de la plateforme
                balle.x = start_x
                balle.y = start_y
                balle.vx = random.choice([-4, 4])
                balle.vy = -4
                # mettre à jour coords graphiques
                canvas.coords(balle.id, balle.x-balle.rayon, balle.y-balle.rayon,
                              balle.x+balle.rayon, balle.y+balle.rayon)

        # Si toutes les briques sont détruites
        if not gestion_brique.bricks:
            canvas.create_text(canvas_width/2, canvas_height/2, text="VICTOIRE !",
                               fill="yellow", font=("Arial", 28, "bold"))
            begin_button.config(state="normal")
            return

        # Prochain tick (~60 FPS)
        root.after(16, game_loop)

    # Lancer la boucle principale du jeu
    game_loop()


# Attacher la fonction au bouton (après sa définition)
begin_button.config(command=on_begin)

# Lancer la fenêtre
if __name__ == "__main__":
    root.mainloop()
